<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Interactive 3D Solar System Simulation</title>
    <link rel="icon" type="image/svg" href="assets/planet-earth-icon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info-box-left, #info-box-right { 
            font-family: "Inter", sans-serif; 
            
            width: clamp(340px, 25vw, 450px); 
            max-height: 95vh; 
            display: flex; 
            flex-direction: column; 
        }

        #simulation-data-panel {
            min-height: 150px; /
        }
        .info-content { overflow-y: auto; }
        .fact-label { font-weight: 600; color: #a5b4fc; }
        input[type=range] { -webkit-appearance: none; width: 100%; height: 8px; background: #4a5568; border-radius: 5px; outline: none; opacity: 0.7; transition: opacity .2s; }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #a5b4fc; border-radius: 50%; cursor: pointer; }
        input[type=range]::-moz-range-thumb { width: 18px; height: 18px; background: #a5b4fc; border-radius: 50%; cursor: pointer; }
        .label { color: #FFF; font-family: "Inter", sans-serif; font-size: 14px; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; pointer-events: none; background-color: rgba(0, 0, 0, 0.5); padding: 2px 5px; border-radius: 4px; white-space: nowrap; }
        #label-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #modal { font-family: "Inter", sans-serif; }
        .facts-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 12px; 
            align-items: center;}
        button {transition: all 0.15s ease-in-out;}
        button:active {
            transform: scale(0.95);
            opacity: 0.9;}
        @keyframes splash-out {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(1.05); 
            }
        }

        .splash-fade-out {
            animation: splash-out 0.7s ease-out forwards;
        }
    </style>
</head>
<body class="bg-black">
    <audio id="background-music" src="assets/ambient-space-arpeggio-350710.mp3" loop></audio>
    <div id="splash-screen" class="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex flex-col justify-center items-center text-white">
        <h1 class="text-4xl font-bold mb-4">3D Solar System</h1>
        <p class="text-lg mb-8">An Interactive Simulation</p>
        
        <button id="start-btn" class="hidden px-8 py-3 bg-indigo-600 text-white rounded text-lg hover:bg-indigo-700 transition-colors">
            Click to Begin
        </button>
        
        <div id="loading-container" class="mt-8 w-1/3 max-w-xs">
            <div class="w-full bg-gray-700 rounded-full h-2.5">
                <div id="loading-bar" class="bg-indigo-500 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p id="loading-text" class="text-center text-sm mt-2 text-gray-300">Loading assets...</p>
        </div>
    </div>
    <div id="info-box-left" class="hidden absolute top-4 left-4 z-10 p-5 bg-black/60 backdrop-blur-sm text-white rounded-lg shadow-lg max-w-sm border border-gray-700">
        <div class="flex justify-between items-center mb-2">
            <h1 class="text-xl font-bold text-indigo-300">Global Controls</h1>
            <button id="minimize-left" class="text-white text-xl font-bold" title="Minimize Panel"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4" /></svg></button>
        </div>
        <div id="info-content-left" class="info-content space-y-4">
            <div>
                <h2 class="text-md font-semibold mb-2">Simulation Controls</h2>
                <div class="grid grid-cols-5 gap-1 mb-2">
                    <button data-speed="-1" class="speed-btn px-2 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors" title="-1 day/sec">◀◀</button>
                    <button data-speed="0" class="speed-btn px-2 py-1 bg-indigo-500 text-white rounded text-sm hover:bg-indigo-600 transition-colors" title="Pause">❚❚</button>
                    <button data-speed="1" class="speed-btn px-2 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors" title="1 day/sec">▶</button>
                    <button data-speed="10" class="speed-btn px-2 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors" title="10 days/sec">▶▶</button>
                    <button data-speed="50" class="speed-btn px-2 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors" title="50 days/sec">▶▶▶</button>
                </div>
                

<div class="flex justify-between items-center mb-1">
    <label for="speed-input" class="text-sm">Speed (Days/sec):</label>
    <input type="number" id="speed-input" class="w-20 bg-gray-700 text-white rounded p-1 text-sm text-center" value="0.0" step="0.5"></div>
                <input type="range" id="speed-slider" min="-50" max="50" value="0" step="0.5" class="w-full">
            </div>

            <div id="simulation-data-panel">
                <h2 class="text-md font-semibold mb-2">Simulation Data</h2>
                <p class="text-sm mb-1">
                    <span class="fact-label">Date:</span> <span id="current-date">Loading...</span>
                </p>
                <div class="text-sm mb-1">
                    <span class="fact-label">Moon Phase:</span> <span id="moon-phase">Calculating...</span>
                    <button id="moon-phase-info" class="ml-1 text-indigo-300 hover:text-indigo-100 text-xs">[Learn More]</button>
                </div>
                <label for="date-picker" class="text-sm fact-label">Jump to Date:</label>
                <input type="date" id="date-picker" class="w-full bg-gray-700 text-white rounded p-1 text-sm mt-1">
                <button id="date-jump" class="w-full mt-2 px-3 py-1 bg-indigo-500 text-white rounded text-sm hover:bg-indigo-600 transition-colors">Jump</button>
            </div>
            
            <div>
                <h2 class="text-md font-semibold mb-2">Display Options</h2>
                 <div class="flex space-x-2">
                      <button id="toggle-orbits" class="flex-1 px-3 py-1 bg-indigo-500 text-white rounded text-sm hover:bg-indigo-600 transition-colors">Hide Orbits</button>
                      <button id="toggle-labels" class="flex-1 px-3 py-1 bg-indigo-500 text-white rounded text-sm hover:bg-indigo-600 transition-colors">Hide Labels</button>
                 </div>
            </div>

        </div>
    </div>

   <div id="info-box-right" class="hidden absolute top-4 right-4 z-10 p-5 bg-black/60 backdrop-blur-sm text-white rounded-lg shadow-lg max-w-sm border border-gray-700">
    <div class="flex justify-between items-center mb-2">
        <h1 class="text-xl font-bold text-indigo-300">Selection Panel</h1>
        <button id="minimize-right" class="text-white text-xl font-bold" title="Minimize Panel"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4" /></svg></button>
    </div>
     <div id="info-content-right" class="info-content space-y-4">
         <div>
             <h2 class="text-md font-semibold mb-2 text-left">Focus Target</h2>
             <div class="grid grid-cols-3 gap-2 mb-4">
                 <button data-target="sun" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Sun</button>
                 <button data-target="mercury" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Mercury</button>
                 <button data-target="venus" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Venus</button>
                 <button data-target="earth" class="focus-btn px-3 py-1 bg-indigo-500 text-white rounded text-sm hover:bg-indigo-600 transition-colors flex justify-center">Earth</button>
                 <button data-target="moon" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Moon</button>
                 <button data-target="mars" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Mars</button>
                 <button data-target="asteroidBelt" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Asteroids</button>
                 <button data-target="jupiter" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Jupiter</button>
                 <button data-target="saturn" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Saturn</button>
                 <button data-target="uranus" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Uranus</button>
                 <button data-target="neptune" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Neptune</button>
                 <button data-target="pluto" class="focus-btn px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 transition-colors flex justify-center">Pluto</button>
             </div>
                         <div>
                <h2 class="text-md font-semibold mb-2">Target Facts</h2>
                <div id="selection-facts" class="space-y-1"></div>
                 <div id="visibility-toggle-container" class="mt-3"></div>
            </div>
             </div>
         </div>

        </div>
    </div>
    
    <div id="modal" class="hidden fixed inset-0 z-50 bg-black/70 backdrop-blur-sm flex justify-center items-center p-4">
        <div class="bg-gray-800 text-white rounded-lg shadow-xl max-w-lg w-full border border-gray-600">
            <div class="flex justify-between items-center p-4 border-b border-gray-600">
                <h2 id="modal-title" class="text-xl font-bold text-indigo-300">Information</h2>
                <button id="modal-close" class="text-white text-2xl font-bold"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg></button>
            </div>
            <div id="modal-content" class="p-6 text-sm space-y-3">
                </div>
        </div>
    </div>

    <div id="label-container" class="absolute top-0 left-0 w-full h-full" style="pointer-events: none;"></div>
    <div id="tooltip" class="absolute hidden p-2 bg-black/70 backdrop-blur-sm text-white rounded-lg text-sm shadow-md border border-gray-700" style="pointer-events: none; z-index: 100;"></div>

    <div id="floating-controls" class="absolute bottom-5 right-5 z-20">
        <button id="music-toggle" class="text-white hover:opacity-75 transition-opacity" title="Play Music">
            <svg id="speaker-icon" xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
            </svg>
            <svg id="mute-icon" xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M17 14l-2-2m0 0l-2-2m2 2l2-2m-2 2l-2 2" />
            </svg>
        </button>
    </div>

    <script type="module">
        import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
        import { OrbitControls } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js";
        import { CSS2DRenderer, CSS2DObject } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/renderers/CSS2DRenderer.js";
        import { GLTFLoader } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js";

        // --- Global Variables ---
        let scene, camera, renderer, controls, clock, labelRenderer;
        let isPaused = false, simulationSpeed = 0.0, simulationTime = new Date().getTime();
        let raycaster, mouse, hoveredObject = null, tooltipEl;
        let isExperienceStarted = false;
        let dateEl, moonPhaseEl, cameraAnimationTarget = null;
        
        let asteroidInstancedMesh; 
        const ASTEROID_COUNT = 15000; 
        const asteroidInstanceData = []; 
        let asteroidPoints = null; 
        const asteroidPointData = []; 

        let cometTrailPoints; 
        const MAX_TRAIL_POINTS = 500;
        const trailColor = new THREE.Color(0xffffff);

        const worldPosition = new THREE.Vector3();
        let textureLoader, gltfLoader, loadingManager;
        
        // --- Data Structures ---
        const solarSystem = {}; 
        const bodyData = {
            sun: { name: "Sun", radius: 12, orbitalPeriod: null, rotationPeriod: 25.0, color: 0xffff00, texture: createSunTexture, info: "The star at the center of our Solar System, a nearly perfect sphere of hot plasma, heated to incandescence by nuclear fusion reactions in its core, radiating the energy mainly as visible light and infrared radiation.", facts: { "Diameter": "1.39 million km", "Type": "Yellow Dwarf (G2V)", "Surface Temp": "5,500 °C", "Core Temp": "15 million °C", "Age": "4.6 billion years", "Composition": "Hydrogen (73%), Helium (25%)" } },
            mercury: { name: "Mercury", radius: 0.5, orbitalPeriod: 88.0, rotationPeriod: 58.6, orbitRadius: 25, color: 0x888888, texture: createMercuryTexture, info: "The smallest planet in the Solar System and nearest to the Sun. Its orbit has the highest eccentricity of all the Solar System planets, and it has the smallest axial tilt.", facts: { "Diameter": "4,880 km", "Day Length": "58.6 Earth days", "Year Length": "88 Earth days", "Surface Temp": "-173°C to 427°C", "Moons": "0", "Type": "Terrestrial" } },
            venus: { name: "Venus", radius: 0.9, orbitalPeriod: 224.7, rotationPeriod: -243, orbitRadius: 40, color: 0xdedea3, texture: createVenusTexture, info: "The second planet from the Sun, often called Earth's 'sister planet' because of their similar size, mass, proximity to the Sun, and bulk composition. It has the densest atmosphere of the four terrestrial planets, consisting of more than 96% carbon dioxide.", facts: { "Diameter": "12,104 km", "Day Length": "243 Earth days (Retrograde)", "Year Length": "224.7 Earth days", "Surface Temp": "462 °C (Hottest)", "Moons": "0", "Type": "Terrestrial","Atmosphere Pressure": "92x Earth's" } },
            earth: { name: "Earth", radius: 1, orbitalPeriod: 365.25, rotationPeriod: 1.0, orbitRadius: 55, color: 0x497ac1, tilt: 23.5, texture: createEarthTexture, info: "Our home planet, the third planet from the Sun and the only astronomical object known to harbor life. About 29.2% of Earth's surface is land consisting of continents and islands.", facts: { "Diameter": "12,742 km", "Population": "~8 billion", "Day Length": "24 hours", "Year Length": "365.25 days", "Moons": "1", "Type": "Terrestrial", "Atmosphere": "Nitrogen (78%), Oxygen (21%)" } },
            moon: { name: "Moon", radius: 0.3, orbitalPeriod: 27.3, rotationPeriod: 27.3, orbitTilt: 5.1, orbitRadius: 5.5, color: 0x888888, texture: createMoonTexture, info: "Earth's only natural satellite. It is the fifth largest satellite in the Solar System, and the largest among planetary satellites relative to the size of the planet that it orbits.", facts: { "Diameter": "3,474 km", "Orbit Time": "27.3 days (Sidereal)", "Surface Temp": "-173°C (night) to 127°C (day)", "Gravity": "1/6th of Earth's", "Tidally Locked": "Yes", "Type": "Terrestrial Body" } },
            mars: { name: "Mars", radius: 0.7, orbitalPeriod: 687, rotationPeriod: 1.03, orbitRadius: 75, color: 0xc1440e, texture: createMarsTexture, info: "The fourth planet from the Sun and the second-smallest planet in the Solar System, being larger than only Mercury. In English, Mars carries the name of the Roman god of war and is often referred to as the 'Red Planet'.", facts: { "Diameter": "6,779 km", "Day Length": "24.6 hours", "Year Length": "687 Earth days", "Surface Temp": "-63 °C (avg)", "Moons": "2 (Phobos & Deimos)", "Type": "Terrestrial", "Tallest Volcano": "Olympus Mons (21.9 km)" } },
            asteroidBelt: { name: "Asteroid Belt", radius: null, orbitalPeriod: 1825, rotationPeriod: null, orbitRadius: 102.5, info: "A torus-shaped region in the Solar System, located roughly between the orbits of the planets Jupiter and Mars, that is occupied by a great many solid, irregularly shaped bodies, of many sizes but much smaller than planets, called asteroids or minor planets.", facts: { "Location": "Between Mars & Jupiter", "Total Mass": "~4% of the Moon", "Largest Object": "Ceres (dwarf planet)", "Composition": "Rock, Metal", "Approx Width": "1 AU" } },
            jupiter: { name: "Jupiter", radius: 5, orbitalPeriod: 4333, rotationPeriod: 0.41, orbitRadius: 130, color: 0xc9a888, texture: createJupiterTexture, info: "The fifth planet from the Sun and the largest in the Solar System. It is a gas giant with a mass more than two and a half times that of all the other planets in the Solar System combined, but slightly less than one-thousandth the mass of the Sun.", facts: { "Diameter": "139,820 km", "Day Length": "9.9 Earth hours (Fastest)", "Year Length": "11.9 Earth years", "Type": "Gas Giant", "Moons": "95 (known)", "Great Red Spot": "Persistent anticyclonic storm" } },
            saturn: { name: "Saturn", radius: 4.5, orbitalPeriod: 10759, rotationPeriod: 0.44, orbitRadius: 190, color: 0xe3d9b9, texture: createSaturnTexture, info: "The sixth planet from the Sun and the second-largest in the Solar System, after Jupiter. It is a gas giant with an average radius of about nine and a half times that of Earth. It is famous for its prominent ring system.", facts: { "Diameter": "116,460 km", "Day Length": "10.7 Earth hours", "Year Length": "29.5 Earth years", "Type": "Gas Giant", "Moons": "146 (known)", "Rings": "Made of ice particles, rock debris, dust" } },
            uranus: { name: "Uranus", radius: 3, orbitalPeriod: 30687, rotationPeriod: -0.72, orbitRadius: 250, color: 0xafdbf5, texture: createUranusTexture, info: "The seventh planet from the Sun. Its name is a reference to the Greek god of the sky, Uranus. It has the third-largest planetary radius and fourth-largest planetary mass in the Solar System. Uranus is similar in composition to Neptune, and both have bulk chemical compositions which differ from that of the larger gas giants Jupiter and Saturn.", facts: { "Diameter": "50,724 km", "Day Length": "17.2 Earth hours (Retrograde)", "Year Length": "84 Earth years", "Type": "Ice Giant", "Moons": "27 (known)", "Axial Tilt": "97.77° (Extreme seasons)" } },
            neptune: { name: "Neptune", radius: 2.9, orbitalPeriod: 60190, rotationPeriod: 0.67, orbitRadius: 310, color: 0x5b76f5, texture: createNeptuneTexture, info: "The eighth and farthest-known Solar planet from the Sun. In the Solar System, it is the fourth-largest planet by diameter, the third-most-massive planet, and the densest giant planet. It is 17 times the mass of Earth, and slightly more massive than its near-twin Uranus.", facts: { "Diameter": "49,244 km", "Day Length": "16.1 Earth hours", "Year Length": "164.8 Earth years", "Type": "Ice Giant", "Moons": "14 (known)", "Winds": "Supersonic (up to 2,100 km/h)" } },
            pluto: { name: "Pluto", radius: 0.35, orbitalPeriod: 90560, rotationPeriod: -6.4, orbitRadius: 360, orbitTilt: 17.2, color: 0xeadac7,info: "A dwarf planet in the Kuiper Belt, a ring of bodies beyond the orbit of Neptune. It was the first and the largest Kuiper Belt object to be discovered. For 76 years, it was considered the ninth planet.",facts: { "Type": "Dwarf Planet (Kuiper Belt Object)", "Diameter": "2,377 km", "Year Length": "248 Earth years", "Surface Temp": "-229 °C (avg)", "Moons": "5 (Charon, Styx, Nix, Kerberos, Hydra)", "Atmosphere": "Thin (Nitrogen, Methane, CO)"} },
        };

        // --- Moon Phase Info ---
        const moonPhaseInfo = {
            "New Moon": { title: "New Moon", info: "The Moon is between the Earth and Sun, so the sunlit side faces away from Earth. The Moon appears very dark or invisible from Earth." },
            "Waxing Crescent": { title: "Waxing Crescent", info: "As the Moon orbits Earth, a small sliver (crescent) of the sunlit side becomes visible. 'Waxing' means the illuminated portion is growing." },
            "First Quarter": { title: "First Quarter", info: "The Moon has completed about a quarter of its orbit since the New Moon. From Earth, it appears as a half-moon, illuminated on the right side (in the Northern Hemisphere)." },
            "Waxing Gibbous": { title: "Waxing Gibbous", info: "More than half of the Moon is illuminated, and the lit portion continues to grow. 'Gibbous' refers to the shape being larger than a semicircle but smaller than a full circle." },
            "Full Moon": { title: "Full Moon", info: "The Earth is positioned between the Sun and Moon. The entire face of the Moon visible from Earth is illuminated by the Sun." },
            "Waning Gibbous": { title: "Waning Gibbous", info: "After the Full Moon, the illuminated portion starts to decrease. 'Waning' means shrinking. More than half is still lit, but the lit area is shrinking from the right (in the Northern Hemisphere)." },
            "Last Quarter": { title: "Last Quarter", info: "Also known as Third Quarter. The Moon has completed about three-quarters of its orbit. It appears as a half-moon again, but this time illuminated on the left side (in the Northern Hemisphere)." },
            "Waning Crescent": { title: "Waning Crescent", info: "A small crescent sliver is visible, illuminated on the left side (in the Northern Hemisphere). The lit portion continues to shrink until the New Moon begins the cycle again." }
        };

        // --- Music Setup ---
        let musicPlaying = false;
        const musicElement = document.getElementById("background-music");
        const musicButton = document.getElementById("music-toggle");
        function toggleMusic() {
            const speakerIcon = document.getElementById("speaker-icon");
            const muteIcon = document.getElementById("mute-icon");

            if (musicPlaying) {
                musicElement.pause();
                musicPlaying = false;
                musicButton.title = "Play Music";
                speakerIcon.classList.remove("hidden");
                muteIcon.classList.add("hidden");
            } else {
                const playPromise = musicElement.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        musicPlaying = true;
                        musicButton.title = "Mute Music";
                        muteIcon.classList.remove("hidden");
                        speakerIcon.classList.add("hidden");
                    }).catch(error => {
                        console.error("Audio playback failed:", error);
                        musicPlaying = false;
                        musicButton.title = "Play Failed";
                        speakerIcon.classList.remove("hidden");
                        muteIcon.classList.add("hidden");
                    });
                }
            }
        }
        // --- Helper Functions ---
        function getMoonPhase(date) { 
             const knownNewMoon = new Date("2024-01-11T00:00:00Z"); const synodicMonth = 29.530588; const diffTime = date.getTime() - knownNewMoon.getTime(); const diffDays = diffTime / (1000 * 60 * 60 * 24); const phaseDays = (diffDays % synodicMonth + synodicMonth) % synodicMonth;
             if (phaseDays < 1.84) return "New Moon"; if (phaseDays < 5.53) return "Waxing Crescent"; if (phaseDays < 9.23) return "First Quarter"; if (phaseDays < 12.93) return "Waxing Gibbous"; if (phaseDays < 16.63) return "Full Moon"; if (phaseDays < 20.33) return "Waning Gibbous"; if (phaseDays < 24.03) return "Last Quarter"; if (phaseDays < 27.73) return "Waning Crescent"; return "New Moon"; 
         }
        function createOrbit(radius, inclination = 0) { 
             const points = []; const segments = 128; 
             for (let i = 0; i <= segments; i++) { 
                 const theta = (i / segments) * Math.PI * 2; 
                 points.push(new THREE.Vector3(Math.cos(theta) * radius, Math.sin(theta) * radius * Math.sin(inclination), Math.sin(theta) * radius * Math.cos(inclination))); 
             } 
             const geometry = new THREE.BufferGeometry().setFromPoints(points); 
             const material = new THREE.LineBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.3 }); 
             return new THREE.Line(geometry, material); 
         }
        function createStarfield() { 
             const starVertices = []; for (let i = 0; i < 15000; i++) { const x = THREE.MathUtils.randFloatSpread(2000); const y = THREE.MathUtils.randFloatSpread(2000); const z = THREE.MathUtils.randFloatSpread(2000); starVertices.push(x, y, z); } const starGeometry = new THREE.BufferGeometry(); starGeometry.setAttribute("position", new THREE.Float32BufferAttribute(starVertices, 3)); const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, sizeAttenuation: true }); scene.add(new THREE.Points(starGeometry, starMaterial)); 
         }
        function createGlowSprite(color, size) { 
            const canvas = document.createElement("canvas"); 
            canvas.width = 128; 
            canvas.height = 128; 
            const context = canvas.getContext("2d"); 

            const colorString = `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}`; 
            
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0, 
                canvas.width / 2, canvas.height / 2, canvas.width / 2 
            ); 
            

            gradient.addColorStop(0, `${colorString}, 1)`);     
            gradient.addColorStop(0.3, `${colorString}, 0.9)`); 
            gradient.addColorStop(1, `${colorString}, 0)`);     
            
            context.fillStyle = gradient; 
            context.fillRect(0, 0, canvas.width, canvas.height); 
            
            const texture = new THREE.CanvasTexture(canvas); 
            
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true, 
                blending: THREE.AdditiveBlending,
                depthWrite: false 
                
            }); 
            
            const sprite = new THREE.Sprite(material); 
            sprite.scale.set(size, size, 1); 
            return sprite; 
        }

        // --- Procedural Texture Functions ---
        function createNoiseCanvas(width, height, scale, octaves, persistence, lacunarity, seed) { const canvas = document.createElement("canvas"); canvas.width = width; canvas.height = height; const ctx = canvas.getContext("2d"); const imageData = ctx.createImageData(width, height); let m_w = 123456789 + seed; let m_z = 987654321 + seed; const random = () => { m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & 0xffffffff; m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & 0xffffffff; let result = ((m_z << 16) + m_w) & 0xffffffff; result = (result + 0.5) / 4294967296.0; return result; }; const noise = (x, y) => { const ix = Math.floor(x); const iy = Math.floor(y); const fx = x - ix; const fy = y - iy; const v = (x, y) => { const n = ix + iy * 57 + seed; m_w = (n << 13) ^ n; m_z = (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff; return 1.0 - (m_w / 1073741824.0); }; const a = v(ix, iy); const b = v(ix + 1, iy); const c = v(ix, iy + 1); const d = v(ix + 1, iy + 1); const ux = fx * fx * (3.0 - 2.0 * fx); const uy = fy * fy * (3.0 - 2.0 * fy); return a + (b - a) * ux + (c - a) * uy * (1.0 - ux) + (d - b) * uy * ux; }; for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { let amp = 1, freq = 1, noiseVal = 0; for(let i = 0; i < octaves; i++) { const sx = x / scale * freq; const sy = y / scale * freq; const pVal = noise(sx, sy) * 2 - 1; noiseVal += pVal * amp; amp *= persistence; freq *= lacunarity; } const val = (noiseVal + 1) * 0.5 * 255; const idx = (y * width + x) * 4; imageData.data[idx] = imageData.data[idx+1] = imageData.data[idx+2] = val; imageData.data[idx+3] = 255; } } ctx.putImageData(imageData, 0, 0); return canvas; }
        function createSunTexture() { const canvas = document.createElement("canvas"); canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext("2d"); ctx.fillStyle = "#ff6600"; ctx.fillRect(0, 0, 512, 256); const nc = createNoiseCanvas(512, 256, 20, 4, 0.5, 2, 1); ctx.globalAlpha = 0.2; ctx.filter = "contrast(1.5)"; ctx.drawImage(nc, 0, 0); ctx.globalAlpha = 0.6; ctx.filter = "none"; ctx.fillStyle = "#330000"; for(let i=0; i<20; i++){ ctx.beginPath(); ctx.ellipse(Math.random()*512, Math.random()*256, Math.random()*10+2, Math.random()*5+2, 0, 0, 2*Math.PI); ctx.fill(); } ctx.globalAlpha = 0.1; ctx.fillStyle = "#ffff99"; for(let i=0; i<40; i++){ ctx.beginPath(); ctx.ellipse(Math.random()*512, Math.random()*256, Math.random()*15+5, Math.random()*8+3, Math.random()*Math.PI, 0, 2*Math.PI); ctx.fill(); } ctx.globalAlpha = 0.3; const pg = ctx.createLinearGradient(0,0,0,256); pg.addColorStop(0,"black"); pg.addColorStop(0.3,"transparent"); pg.addColorStop(0.7,"transparent"); pg.addColorStop(1,"black"); ctx.fillStyle = pg; ctx.fillRect(0,0,512,256); ctx.globalAlpha = 1.0; return new THREE.CanvasTexture(canvas); }
        function createEarthTexture() { const canvas = document.createElement("canvas"); canvas.width = 1024; canvas.height = 512; const ctx = canvas.getContext("2d"); ctx.fillStyle = "#497ac1"; ctx.fillRect(0, 0, 1024, 512); const nc = createNoiseCanvas(1024, 512, 150, 6, 0.5, 2, 2); const nctx = nc.getContext("2d"); const nd = nctx.getImageData(0,0,1024,512); const ld = ctx.createImageData(1024,512); for (let i=0; i<nd.data.length; i+=4) { const v=nd.data[i]; const y=Math.floor((i/4)/1024); const pf=Math.sin((y/512)*Math.PI); if(v>100*pf){ let c="#5d943b"; if(v>160*pf) c="#b8a679"; if(v>190*pf) c="#94775c"; const [r,g,b]=c.match(/\w\w/g).map(x=>parseInt(x,16)); ld.data[i]=r; ld.data[i+1]=g; ld.data[i+2]=b; ld.data[i+3]=255; } else { ld.data[i+3]=0; } } ctx.putImageData(ld,0,0); const pg = ctx.createLinearGradient(0,0,0,512); pg.addColorStop(0,"white"); pg.addColorStop(0.15,"rgba(255,255,255,0)"); pg.addColorStop(0.85,"rgba(255,255,255,0)"); pg.addColorStop(1,"white"); ctx.fillStyle=pg; ctx.fillRect(0,0,1024,512); return new THREE.CanvasTexture(canvas); }
        function createCloudTexture() { const canvas = createNoiseCanvas(1024, 512, 100, 8, 0.5, 2, 3); const ctx = canvas.getContext("2d"); const id = ctx.getImageData(0,0,1024,512); for(let i=0; i<id.data.length; i+=4){ const v=id.data[i]; if(v<120){ id.data[i+3]=0; } else { id.data[i]=255; id.data[i+1]=255; id.data[i+2]=255; id.data[i+3]=(v-120); } } ctx.putImageData(id,0,0); return new THREE.CanvasTexture(canvas); }
        function createMoonTexture() { const canvas = document.createElement("canvas"); canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext("2d"); ctx.fillStyle = "#888888"; ctx.fillRect(0, 0, 512, 256); const nc = createNoiseCanvas(512, 256, 30, 6, 0.4, 2, 4); ctx.globalAlpha = 0.5; ctx.filter = "contrast(1.2)"; ctx.drawImage(nc,0,0); ctx.globalAlpha = 1.0; ctx.filter = "none"; for(let i=0; i<300; i++){ const x=Math.random()*512; const y=Math.random()*256; const r=Math.random()*10+1; ctx.fillStyle="rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.arc(x,y,r,0,2*Math.PI); ctx.fill(); ctx.strokeStyle="rgba(255,255,255,0.2)"; ctx.lineWidth=0.5; ctx.beginPath(); ctx.arc(x+0.5,y+0.5,r,0,2*Math.PI); ctx.stroke(); } const mc = createNoiseCanvas(512,256,150,3,0.5,2,5); const mctx = mc.getContext("2d"); const md = mctx.getImageData(0,0,512,256); const fd = ctx.getImageData(0,0,512,256); for(let i=0; i<md.data.length; i+=4){ const v=md.data[i]; if(v>150){ fd.data[i]*=0.7; fd.data[i+1]*=0.7; fd.data[i+2]*=0.7; } } ctx.putImageData(fd,0,0); return new THREE.CanvasTexture(canvas); }
        function createMercuryTexture() { return createMoonTexture(); } 
        function createVenusTexture() { const canvas = document.createElement("canvas"); canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext("2d"); ctx.fillStyle = "#dedea3"; ctx.fillRect(0, 0, 512, 256); const nc = createNoiseCanvas(512, 256, 100, 6, 0.6, 2.2, 11); ctx.globalAlpha = 0.4; ctx.filter = "contrast(1.3)"; ctx.drawImage(nc,0,0); ctx.globalAlpha = 0.2; ctx.fillStyle = "rgba(255,255,255,0.5)"; for(let y=0; y<256; y+=30+Math.random()*10){ ctx.fillRect(0,y,512,15+Math.random()*5); } return new THREE.CanvasTexture(canvas); }
        function createMarsTexture() { const canvas = document.createElement("canvas"); canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext("2d"); ctx.fillStyle = "#c1440e"; ctx.fillRect(0, 0, 512, 256); const nc = createNoiseCanvas(512, 256, 80, 6, 0.4, 2, 6); ctx.globalAlpha = 0.3; ctx.filter = "contrast(1.5)"; ctx.drawImage(nc,0,0); ctx.globalAlpha = 0.2; ctx.filter = "none"; ctx.fillStyle = "#5e2008"; for(let i=0; i<150; i++){ ctx.beginPath(); ctx.ellipse(Math.random()*512, Math.random()*256, Math.random()*20+5, Math.random()*15+5, Math.random()*Math.PI, 0, 2*Math.PI); ctx.fill(); } ctx.globalAlpha = 1.0; const pg = ctx.createLinearGradient(0,0,0,256); pg.addColorStop(0,"rgba(255,255,255,0.8)"); pg.addColorStop(0.1,"rgba(255,255,255,0)"); pg.addColorStop(0.9,"rgba(255,255,255,0)"); pg.addColorStop(1,"rgba(255,255,255,0.8)"); ctx.fillStyle = pg; ctx.fillRect(0,0,512,256); return new THREE.CanvasTexture(canvas); }
        function createGasGiantTexture(color1, color2, seed) { const canvas = document.createElement("canvas"); canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext("2d"); ctx.fillStyle = color1; ctx.fillRect(0, 0, 512, 256); const nc = createNoiseCanvas(512, 256, 50, 4, 0.5, 2, seed); const nd = nc.getContext("2d").getImageData(0,0,512,256); const bd = ctx.createImageData(512,256); for (let y=0; y<256; y++){ const band=Math.sin(y/20)>0; for (let x=0; x<512; x++){ const i=(y*512+x)*4; const n=nd.data[i]/255; const c=(band?color1:color2); const [r,g,b]=c.match(/\w\w/g).map(x=>parseInt(x,16)); const f=0.7+n*0.6; bd.data[i]=r*f; bd.data[i+1]=g*f; bd.data[i+2]=b*f; bd.data[i+3]=255; } } ctx.putImageData(bd,0,0); if(seed===7){ ctx.fillStyle="rgba(168,85,50,0.7)"; ctx.beginPath(); ctx.ellipse(100,100,30,20,0.5,0,2*Math.PI); ctx.fill(); ctx.filter="blur(3px)"; ctx.fill(); } return new THREE.CanvasTexture(canvas); }
        function createJupiterTexture() { return createGasGiantTexture("#c9a888", "#a1886b", 7); }
        function createSaturnTexture() { return createGasGiantTexture("#e3d9b9", "#c4b998", 8); }
        function createIceGiantTexture(color, seed) { const canvas = document.createElement("canvas"); canvas.width = 256; canvas.height = 128; const ctx = canvas.getContext("2d"); ctx.fillStyle = color; ctx.fillRect(0, 0, 256, 128); const nc = createNoiseCanvas(256, 128, 40, 6, 0.5, 2, seed); ctx.globalAlpha = 0.3; ctx.filter = "contrast(1.2)"; ctx.drawImage(nc,0,0); ctx.globalAlpha = 0.1; ctx.fillStyle = "rgba(255,255,255,0.5)"; for(let y=0; y<128; y+=20){ ctx.fillRect(0,y,256,10); } return new THREE.CanvasTexture(canvas); }
        function createUranusTexture() { return createIceGiantTexture("#afdbf5", 9); }
        function createNeptuneTexture() { return createIceGiantTexture("#5b76f5", 10); }

        // --- UI Functions ---
        function setupUI() {
            const splashScreen = document.getElementById("splash-screen");
            const startButton = document.getElementById("start-btn");
            startButton.addEventListener("click", () => {
            isExperienceStarted = true;
            toggleMusic();
            document.getElementById('info-box-left').classList.remove('hidden');
            document.getElementById('info-box-right').classList.remove('hidden');
                splashScreen.classList.add("splash-fade-out");
                setTimeout(() => {splashScreen.style.display = 'none';}, 700); });
            dateEl = document.getElementById("current-date"); moonPhaseEl = document.getElementById("moon-phase"); const speedSlider = document.getElementById("speed-slider");
            setSimulationSpeed(0); 
            document.querySelectorAll(".speed-btn").forEach(btn => btn.addEventListener("click", () => setSimulationSpeed(parseFloat(btn.dataset.speed))));
            speedSlider.addEventListener("input", (e) => setSimulationSpeed(parseFloat(e.target.value)));
            document.querySelectorAll(".focus-btn").forEach(btn => btn.addEventListener("click", () => setFocus(btn.dataset.target, btn)));
            document.getElementById("toggle-orbits").addEventListener("click", (e) => { const show = toggleGroupVisibility("orbit", e.target); e.target.innerText = show ? "Hide Orbits" : "Show Orbits"; e.target.classList.toggle("bg-indigo-500", show); e.target.classList.toggle("hover:bg-indigo-600", show); e.target.classList.toggle("bg-gray-500", !show); e.target.classList.toggle("hover:bg-gray-600", !show); });
            document.getElementById("toggle-labels").addEventListener("click", (e) => { const show = toggleGroupVisibility("label", e.target); e.target.innerText = show ? "Hide Labels" : "Show Labels"; e.target.classList.toggle("bg-indigo-500", show); e.target.classList.toggle("hover:bg-indigo-600", show); e.target.classList.toggle("bg-gray-500", !show); e.target.classList.toggle("hover:bg-gray-600", !show); });
            document.getElementById("date-jump").addEventListener("click", () => { const d = document.getElementById("date-picker").value; if (d) { simulationTime = new Date(d).getTime(); if (isPaused) { updateUI(); updateOrbitalMechanics(); } } });
            document.getElementById("modal-close").addEventListener("click", () => document.getElementById("modal").classList.add("hidden"));
            document.getElementById("moon-phase-info").addEventListener("click", () => { const p = moonPhaseEl.innerText; const i = moonPhaseInfo[p] || {}; showModal(i.title || "Moon Phase", `<p>${i.info || "N/A"}</p>`); });
            document.getElementById("minimize-left").addEventListener("click", () => toggleMinimize("info-content-left", "minimize-left"));
            document.getElementById("minimize-right").addEventListener("click", () => toggleMinimize("info-content-right", "minimize-right"));
            document.getElementById("music-toggle").addEventListener("click", toggleMusic);
            const speedInput = document.getElementById("speed-input");
            speedInput.addEventListener("change", (e) => {
                const newSpeed = parseFloat(e.target.value);
                if (!isNaN(newSpeed)) {
                    setSimulationSpeed(newSpeed);
                }
            });
        }

        function setSimulationSpeed(speed) { 
            simulationSpeed = speed; 
            isPaused = (speed === 0); 

            const speedInput = document.getElementById("speed-input");
            const speedSlider = document.getElementById("speed-slider");

            if (speedInput) speedInput.value = speed.toFixed(1); 
            if (speedSlider) speedSlider.value = speed; 

            document.querySelectorAll(".speed-btn").forEach(btn => { 
                const btnSpeed = parseFloat(btn.dataset.speed); 
                const isActive = (speed === btnSpeed); 
                btn.classList.toggle("bg-indigo-500", isActive); 
                btn.classList.toggle("hover:bg-indigo-600", isActive); 
                btn.classList.toggle("bg-gray-500", !isActive); 
                btn.classList.toggle("hover:bg-gray-600", !isActive); 
            });
        }
        function setFocus(targetName, targetButton) {
            const data = bodyData[targetName];
            if (!data) {
                console.warn(`No data found for target: ${targetName}`);
                return;
            }
            if (targetName === "asteroidBelt") {

                const beltData = bodyData.asteroidBelt;
                const simDays = simulationTime / (1000 * 60 * 60 * 24);
                const orbitAngle = (simDays / beltData.orbitalPeriod) * Math.PI * 2;

                const x = Math.cos(orbitAngle) * beltData.orbitRadius;
                const z = Math.sin(orbitAngle) * beltData.orbitRadius;
                const targetPosition = new THREE.Vector3(x, 0, z);

                
                const cameraPosition = new THREE.Vector3(
                    targetPosition.x,
                    targetPosition.y + 20, 
                    targetPosition.z - 50  
                );

                cameraAnimationTarget = {
                    camera: cameraPosition,
                    target: targetPosition
                };

           
            } else {
                const targetObject = solarSystem[targetName]?.mesh;
                if (targetObject) {
                    const targetPosition = new THREE.Vector3();
                    targetObject.getWorldPosition(targetPosition);

                    
                    const direction = new THREE.Vector3().subVectors(camera.position, targetPosition).normalize();
                    const distance = (data.radius || 1) * 5; 
                    const cameraPosition = new THREE.Vector3().copy(targetPosition).addScaledVector(direction, Math.max(distance, 5));

                    cameraAnimationTarget = {
                        camera: cameraPosition,
                        target: targetPosition
                    };
                } else {
                    console.warn(`Focus target mesh not found for: ${targetName}`);
                    return;
                }
            }

            document.querySelectorAll(".focus-btn").forEach(btn => {
                btn.classList.replace("bg-indigo-500", "bg-gray-500");
                btn.classList.replace("hover:bg-indigo-600", "hover:bg-gray-600");
            });
            if (targetButton) {
                targetButton.classList.replace("bg-gray-500", "bg-indigo-500");
                targetButton.classList.replace("hover:bg-gray-600", "hover:bg-indigo-600");
            }
            updateSelectionUI(targetName);
        }
        function updateSelectionUI(targetName) {
              const data = bodyData[targetName] || {}; 
              const systemObject = solarSystem[targetName] || {}; 
              const isCurrentlyVisible = systemObject.isVisible !== false; 
              const factsContainer = document.getElementById("selection-facts"); 
              const visibilityContainer = document.getElementById("visibility-toggle-container");
              let titleHtml = `<h3 class="text-lg font-bold">${data.name || "N/A"}`; const infoBtnId = `info-btn-${targetName}`;
              if (data.facts) { titleHtml += `<button id="${infoBtnId}" data-target="${targetName}" class="info-btn ml-1 text-indigo-300 hover:text-indigo-100 text-xs">[Learn More]</button></h3>`; } else { titleHtml += `</h3>`; }
              let html = titleHtml; html += `<p class="text-sm text-gray-300 mb-2">${data.info || ""}</p>`;
              if (data.orbitalPeriod) { html += `<p class="text-sm"><span class="fact-label">Orbital Period:</span> ${data.orbitalPeriod} Earth days</p>`; }
              if (data.rotationPeriod) { html += `<p class="text-sm"><span class="fact-label">Rotation Period:</span> ${data.rotationPeriod} Earth days</p>`; }
              if (factsContainer) factsContainer.innerHTML = html;
              if (visibilityContainer && (systemObject.mesh || targetName === "asteroidBelt")) { 
                   const btnText = isCurrentlyVisible ? `Hide ${data.name}` : `Show ${data.name}`; const btnColor = isCurrentlyVisible ? "bg-red-500 hover:bg-red-600" : "bg-green-500 hover:bg-green-600"; const toggleBtnId = `toggle-visibility-${targetName}`; 
                   visibilityContainer.innerHTML = `<button id="${toggleBtnId}" data-target="${targetName}" class="w-full px-3 py-1 ${btnColor} text-white rounded text-sm transition-colors">${btnText}</button>`;
                  const toggleBtn = document.getElementById(toggleBtnId);
                  if (toggleBtn) { toggleBtn.onclick = (e) => { toggleObjectVisibility(e.target.dataset.target); updateSelectionUI(targetName); }; }
              } else if (visibilityContainer) { visibilityContainer.innerHTML = ""; }
              const infoBtn = document.getElementById(infoBtnId);
              if (infoBtn) { infoBtn.onclick = handleInfoButtonClick; } 
         }

        function handleInfoButtonClick(e) { 
              const target = e.target.dataset.target; const targetData = bodyData[target];
              if (targetData && targetData.facts) { let factsModalContent = `<p class="text-base mb-2">${targetData.info}</p><hr class="my-3 border-gray-600"><h4 class="text-md font-semibold mb-2">Detailed Facts:</h4>`; factsModalContent += Object.entries(targetData.facts).map(([k, v]) => `<p><span class="fact-label">${k}:</span> ${v}</p>`).join(""); showModal(targetData.name, factsModalContent); } 
              else if (targetData) { showModal(targetData.name, `<p>${targetData.info}</p>`); }
         }
        
        function toggleObjectVisibility(targetName) {
            const systemObject = solarSystem[targetName];
            if (!systemObject || (!systemObject.mesh && targetName !== "asteroidBelt")) return;
            
            const newState = !(systemObject.isVisible !== false);
            systemObject.isVisible = newState;

            if (systemObject.mesh) systemObject.mesh.visible = newState;
            if (systemObject.label) systemObject.label.visible = newState;
            
            if (systemObject.orbit && systemObject.orbit.parent === scene) {
                systemObject.orbit.visible = newState;
            }


            if (targetName === "moon") {
                if (systemObject.orbit) {
                    systemObject.orbit.visible = newState;
                }
            }

            if (targetName === "saturn" && solarSystem.saturn?.rings) { 
                solarSystem.saturn.rings.visible = newState; 
            }
            if (targetName === "asteroidBelt" && solarSystem.asteroidBelt?.mesh) { 
                solarSystem.asteroidBelt.mesh.visible = newState; 
            }
        }
        function showModal(title, content) { document.getElementById("modal-title").innerText = title; document.getElementById("modal-content").innerHTML = content; document.getElementById("modal").classList.remove("hidden"); }
        function toggleMinimize(contentId, buttonId) {
        const content = document.getElementById(contentId);
        const button = document.getElementById(buttonId);
        content.classList.toggle("hidden");

        button.innerHTML = content.classList.contains("hidden") 
            ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>` 
            : `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4" /></svg>`;
    }
        function toggleGroupVisibility(type, button) { 
               const shouldHide = button.innerText.startsWith("Hide"); const newState = !shouldHide; 
               for (const id in solarSystem) {
                   const obj = solarSystem[id]; if (!obj) continue; 
                   if (obj.isVisible === false && shouldHide) continue; 
                   if (type === "label" && obj.label) obj.label.visible = newState;
                   if (type === "orbit" && obj.orbit && obj.orbit.parent === scene) obj.orbit.visible = newState; 
                   if (type === "orbit" && id === "moon" && obj.orbit) {
                       obj.orbit.visible = newState;
                   }
               }
               const currentTarget = document.querySelector(".focus-btn.bg-indigo-500")?.dataset.target;
               if (currentTarget) updateSelectionUI(currentTarget);
               return newState; 
        }

        // --- Main Scene Setup ---
        function createCelestialBody(id, data) {
            
            if (id === "asteroidBelt" || id === "moon") return;

            const modelFileName = `${id}.glb`;
            const modelPath = new URL(`assets/models/${modelFileName}`, window.location.href).href;

            gltfLoader.load(modelPath,
                function (gltf) { 
                    const loadedMesh = gltf.scene; 
                    const initialBox = new THREE.Box3().setFromObject(loadedMesh);
                    const size = initialBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z) || 1;
                    const scaleFactor = (data.radius * 2) / maxDim;
                    loadedMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    
                    let finalMeshObject;

                    if (id === 'mercury' || id === 'venus' || id === 'pluto') {
                        const container = new THREE.Object3D();
                        const scaledBox = new THREE.Box3().setFromObject(loadedMesh);
                        const center = new THREE.Vector3();
                        scaledBox.getCenter(center);

                        
                        loadedMesh.position.sub(center);

                        container.add(loadedMesh);
                        finalMeshObject = container;
                    } else {
                        finalMeshObject = loadedMesh; 
                    }
                    
                    finalMeshObject.userData.id = id;
                    const objectToTilt = (id === 'mercury' || id === 'venus' || id === 'pluto') ? loadedMesh : finalMeshObject;
                    objectToTilt.rotation.x = (data.tilt || 0) * (Math.PI / 180);
                    
                    solarSystem[id] = { ...data, isVisible: true, mesh: finalMeshObject };
                    scene.add(finalMeshObject);

                    
                    if (id === "sun") {
                        finalMeshObject.traverse(c => { if (c.isMesh) { c.material.emissive = new THREE.Color(0xffff00); c.material.emissiveIntensity = 1; }});
                        finalMeshObject.add(new THREE.PointLight(0xffffff, 2, 0, 0));
                        finalMeshObject.add(createGlowSprite(new THREE.Color(0xfd5e53), data.radius * 3));
                    }

                    if (id === "earth") {
                        const cloudGeo = new THREE.SphereGeometry(data.radius * 1.01, 32, 32);
                        const cloudMat = new THREE.MeshPhongMaterial({ map: createCloudTexture(), transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, shininess: 0 });
                        solarSystem.earth.clouds = new THREE.Mesh(cloudGeo, cloudMat);
                        solarSystem.earth.clouds.raycast = () => {};
                        loadedMesh.add(solarSystem.earth.clouds);

                       
                        const earthMeshRef = finalMeshObject;
                        const moonData = bodyData.moon;
                        const moonModelPath = new URL(`assets/models/moon.glb`, window.location.href).href;

                        gltfLoader.load(moonModelPath, function(moonGltf) {
                            const moonMesh = moonGltf.scene;
                            const initialMoonBox = new THREE.Box3().setFromObject(moonMesh);
                            const moonSize = initialMoonBox.getSize(new THREE.Vector3());
                            const moonMaxDim = Math.max(moonSize.x, moonSize.y, moonSize.z) || 1;
                            const moonScaleFactor = (moonData.radius * 2) / moonMaxDim;
                            moonMesh.scale.set(moonScaleFactor, moonScaleFactor, moonScaleFactor);
                            moonMesh.userData.id = 'moon';
                            const earthBox = new THREE.Box3().setFromObject(earthMeshRef);
                            const earthSize = earthBox.getSize(new THREE.Vector3());
                            const earthRadiusActual = Math.max(earthSize.x, earthSize.y, earthSize.z) / 2;
                            const dynamicMoonOrbitRadius = earthRadiusActual + moonData.radius + 1.5;

                            const moonOrbitContainer = new THREE.Object3D();
                            moonOrbitContainer.rotation.z = moonData.orbitTilt * (Math.PI / 180);
                            scene.add(moonOrbitContainer);
                            moonOrbitContainer.add(moonMesh);

                            const moonBox = new THREE.Box3().setFromObject(moonMesh);
                            const center = new THREE.Vector3();
                            moonBox.getCenter(center);
                            moonMesh.position.set(dynamicMoonOrbitRadius, -center.y, 0);

                            const moonOrbit = createOrbit(dynamicMoonOrbitRadius);
                            moonOrbit.userData.type = "orbit";
                            moonOrbitContainer.add(moonOrbit);
                            
                            const moonLabelDiv = document.createElement("div");
                            moonLabelDiv.className = "label";
                            moonLabelDiv.textContent = moonData.name;
                            const moonLabel = new CSS2DObject(moonLabelDiv);
                            moonLabel.position.set(0, moonData.radius + 0.3, 0);
                            moonLabel.userData.type = "label";
                            moonMesh.add(moonLabel);
                            
                            solarSystem.moon = {
                                ...moonData, mesh: moonMesh, moonOrbitContainer: moonOrbitContainer,
                                label: moonLabel, isVisible: true, orbitRadius: dynamicMoonOrbitRadius, orbit: moonOrbit
                            };
                        }, undefined, function(error) {
                            console.error("CRITICAL ERROR: The moon.glb model failed to load.", error);
                        });
                    } 

                    
                    const labelDiv = document.createElement("div");
                    labelDiv.className = "label";
                    labelDiv.textContent = data.name;
                    const label = new CSS2DObject(labelDiv);
                    label.position.set(0, data.radius + 0.3, 0);
                    label.userData.type = "label";
                    
                    const objectToLabel = (id === 'mercury' || id === 'venus' || id === 'pluto') ? loadedMesh : finalMeshObject;
                    objectToLabel.add(label);
                    solarSystem[id].label = label;

                    
                    if (data.orbitRadius) {
                        const inclination = (data.orbitTilt || 0) * (Math.PI / 180);
                        const orbit = createOrbit(data.orbitRadius, inclination);
                        orbit.userData.type = "orbit";
                        scene.add(orbit);
                        solarSystem[id].orbit = orbit;
                    }
                },
                undefined,
                function (error) {
                    console.error(`Failed to load model for ${id}: ${modelPath}`, error);
                }
            );
        }
        
        function handleLoadError(id, data, message, error = null) {
              console.error(`${message}${error ? ':' : ''}`, error || '');
        } 


        function loadAsteroidModelAndCreateBelt() {
            const baseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
            let modelPath;
            try { modelPath = new URL("assets/models/asteroid.glb", baseUrl).href; } 
            catch (e) { console.error("Invalid URL for asteroid model"); createAsteroidBeltFallback(); return; }

            gltfLoader.load( modelPath,
                function(gltf) { 
                    let asteroidMeshGeo, asteroidMeshMat;
                    gltf.scene.traverse(child => { if (!asteroidMeshGeo && child.isMesh) { asteroidMeshGeo = child.geometry; asteroidMeshMat = child.material; } });
                    if (!asteroidMeshGeo || !asteroidMeshMat) { console.error("Loaded asteroid GLB does not contain a valid mesh."); createAsteroidBeltFallback(); return; }
                    createAsteroidBeltInstanced(asteroidMeshGeo, asteroidMeshMat);
                },
                undefined, 
                function(error) { 
                    console.error("Failed to load asteroid model, falling back to points.", error);
                    createAsteroidBeltFallback(); 
                }
            );
        }

        function createAsteroidBeltInstanced(geometry, material) {
            const beltRadius = 102.5; const beltWidth = 15; const beltHeight = 3;
            const dummy = new THREE.Object3D(); asteroidInstanceData.length = 0;
            asteroidInstancedMesh = new THREE.InstancedMesh(geometry, material, ASTEROID_COUNT);
            asteroidInstancedMesh.userData.type = "asteroidBelt";
            asteroidInstancedMesh.userData.id = "asteroidBelt";

            const beltAnchor = new THREE.Object3D();
            scene.add(beltAnchor);

            for (let i = 0; i < ASTEROID_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2; const radius = beltRadius + (Math.random() - 0.5) * beltWidth; const y = (Math.random() - 0.5) * beltHeight; const speedFactor = (1 / Math.sqrt(radius / beltRadius)) * (0.8 + Math.random() * 0.4);
                asteroidInstanceData.push({ radius, y, initialAngle: angle, speedFactor });
                dummy.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                const scale = 0.03 + Math.random() * 0.07; dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix(); asteroidInstancedMesh.setMatrixAt(i, dummy.matrix);
            }

            const beltLabelDiv = document.createElement("div");
            beltLabelDiv.className = "label";
            beltLabelDiv.textContent = "Asteroid Belt";
            const beltLabel = new CSS2DObject(beltLabelDiv);
            beltLabel.position.set(0, 5, 0); 
            beltLabel.userData.type = "label";

            beltAnchor.add(beltLabel);

            solarSystem.asteroidBelt = { mesh: asteroidInstancedMesh, label: beltLabel, anchor: beltAnchor, isVisible: true };
            scene.add(asteroidInstancedMesh);
        }

         function setupSkybox() {
              const loader = new THREE.CubeTextureLoader();
              const path = "https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/textures/cube/MilkyWay/";
              const urls = [ path + 'dark-s_px.jpg', path + 'dark-s_nx.jpg', path + 'dark-s_py.jpg', path + 'dark-s_ny.jpg', path + 'dark-s_pz.jpg', path + 'dark-s_nz.jpg' ];
              const texture = loader.load(urls, 
                  () => { scene.background = texture; },
                  undefined, 
                  (error) => { console.error("Failed to load skybox textures, falling back to starfield.", error); createStarfield(); }
              );
         }

        function init() {
            const loadingBar = document.getElementById('loading-bar');
            const loadingContainer = document.getElementById('loading-container');
            const startButton = document.getElementById('start-btn');
            loadingManager = new THREE.LoadingManager();
            loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
                const progress = (itemsLoaded / itemsTotal) * 100;
                loadingBar.style.width = progress + '%';};
            loadingManager.onLoad = function() {
                setTimeout(() => {
                    if(loadingContainer) loadingContainer.style.display = 'none';
                    if(startButton) startButton.classList.remove('hidden');
                }, 300);};
            gltfLoader = new GLTFLoader(loadingManager);
            textureLoader = new THREE.TextureLoader(loadingManager);
            scene = new THREE.Scene(); clock = new THREE.Clock(); 
            textureLoader.setCrossOrigin("anonymous");
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); camera.position.set(0, 50, 150);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.physicallyCorrectLights = true; renderer.outputEncoding = THREE.sRGBEncoding; document.body.appendChild(renderer.domElement);
            labelRenderer = new CSS2DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.id = "label-container"; document.body.appendChild(labelRenderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.enablePan = true; controls.minDistance = 1; controls.maxDistance = 2000; 
            setupSkybox(); setupUI(); 
            
            for (const [id, data] of Object.entries(bodyData)) { 
            if (id !== 'moon') { createCelestialBody(id, data); } 
        }
                    loadAsteroidModelAndCreateBelt(); 
            window.addEventListener("resize", onWindowResize, false);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            tooltipEl = document.getElementById('tooltip');
            window.addEventListener('mousemove', onMouseMove);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            if (tooltipEl.style.display === 'block') {
                tooltipEl.style.left = event.clientX + 15 + 'px';
                tooltipEl.style.top = event.clientY + 'px';
            }
        }
        
        // --- Animation Loop ---
        function updateSimulationTime(delta) { if (!isPaused) { simulationTime += (simulationSpeed * 1000 * 60 * 60 * 24) * delta; } }
        function updateUI() { 
              if (dateEl) dateEl.innerText = new Date(simulationTime).toLocaleString("en-US", { year: "numeric", month: "long", day: "numeric", timeZone: "UTC" }); 
              if (moonPhaseEl) moonPhaseEl.innerText = getMoonPhase(new Date(simulationTime)); 
         }

        function updateOrbitalMechanics() {
            const simDays = simulationTime / (1000 * 60 * 60 * 24);

            // --- Asteroid Belt Animation ---
            if (asteroidInstancedMesh) { 
                const matrix = new THREE.Matrix4();
                const asteroidBasePeriod = bodyData.asteroidBelt.orbitalPeriod || 1825;
                const asteroidBaseAngularSpeed = (2 * Math.PI) / asteroidBasePeriod; 
                for (let i = 0; i < ASTEROID_COUNT; i++) {
                     const data = asteroidInstanceData[i];
                     const currentAngle = data.initialAngle + asteroidBaseAngularSpeed * data.speedFactor * simDays;
                     const x = Math.cos(currentAngle) * data.radius;
                     const z = Math.sin(currentAngle) * data.radius;
                     asteroidInstancedMesh.getMatrixAt(i, matrix);
                     matrix.setPosition(x, data.y, z);
                     asteroidInstancedMesh.setMatrixAt(i, matrix); 
                }
                 asteroidInstancedMesh.instanceMatrix.needsUpdate = true;
             } 

            // --- Planet and Pluto Animation ---
            for (const [id, data] of Object.entries(bodyData)) {
                if (id === "asteroidBelt" || id === "moon") continue; 
                const body = solarSystem[id]; 
                if (!body || !body.mesh) continue; 

                if (data.rotationPeriod) {
                    const rot = (simDays / data.rotationPeriod) * Math.PI * 2; 
                    
                    const objectToRotate = (id === 'mercury' || id === 'venus' || id === 'pluto') ? body.mesh.children[0] : body.mesh;
                    objectToRotate.rotation.y = rot; 
                }

                if (data.orbitRadius) {
                    const orbitAngle = (simDays / data.orbitalPeriod) * Math.PI * 2;
                    if (data.orbitTilt) {
                        const r = data.orbitRadius;
                        const i = data.orbitTilt * (Math.PI / 180);
                        body.mesh.position.set(
                            Math.cos(orbitAngle) * r,
                            Math.sin(orbitAngle) * r * Math.sin(i),
                            Math.sin(orbitAngle) * r * Math.cos(i)
                        );
                    } else {
                        body.mesh.position.set(Math.cos(orbitAngle) * data.orbitRadius, 0, Math.sin(orbitAngle) * data.orbitRadius);
                    }
                }
                
                if (id === "earth" && solarSystem.earth.clouds) {
                    solarSystem.earth.clouds.rotation.y = body.mesh.children[0].rotation.y * 1.5; 
                }
            }
            const belt = solarSystem.asteroidBelt;
                    if (belt && belt.anchor) {
                        const beltData = bodyData.asteroidBelt;
                        const orbitAngle = (simDays / beltData.orbitalPeriod) * Math.PI * 2;
                        const x = Math.cos(orbitAngle) * beltData.orbitRadius;
                        const z = Math.sin(orbitAngle) * beltData.orbitRadius;
                        belt.anchor.position.set(x, 0, z);
                    }

            // --- Moon Animation ---
            const moon = solarSystem.moon;
            const earth = solarSystem.earth;
            if (moon && moon.moonOrbitContainer && moon.orbitalPeriod && earth && earth.mesh) { 
                moon.moonOrbitContainer.position.copy(earth.mesh.position);
                const moonOrbitAngle = (simDays / moon.orbitalPeriod) * Math.PI * 2;
                moon.moonOrbitContainer.rotation.y = moonOrbitAngle; 
                if (moon.rotationPeriod) { 
                    moon.mesh.rotation.y = (simDays / moon.rotationPeriod) * Math.PI * 2; 
                }
            }       
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight); }

        function animate() {
            requestAnimationFrame(animate); const delta = clock.getDelta();
            updateSimulationTime(delta);
            updateOrbitalMechanics(); 
            if (!isPaused) { updateUI(); } 
            if (cameraAnimationTarget) {
            controls.enabled = false; 

            const lerpFactor = 0.05; 
            camera.position.lerp(cameraAnimationTarget.camera, lerpFactor);
            controls.target.lerp(cameraAnimationTarget.target, lerpFactor);

            
            if (camera.position.distanceTo(cameraAnimationTarget.camera) < 0.1) {
                camera.position.copy(cameraAnimationTarget.camera);
                controls.target.copy(cameraAnimationTarget.target);
                cameraAnimationTarget = null; 
            }
        } else {
            controls.enabled = true; 
        }
            if (isExperienceStarted) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);
                let foundObject = null;

                if (intersects.length > 0) {
                    let firstIntersect = intersects[0].object;
                    while (firstIntersect.parent && !firstIntersect.userData.id) {
                        firstIntersect = firstIntersect.parent;
                    }
                    if (firstIntersect.userData.id && bodyData[firstIntersect.userData.id]) {
                        foundObject = firstIntersect;
                    }
                }

                if (hoveredObject !== foundObject) {
                    hoveredObject = foundObject;
                    if (hoveredObject) {
                        const data = bodyData[hoveredObject.userData.id];
                        tooltipEl.style.display = 'block';
                        tooltipEl.innerHTML = `
                            <div class="font-bold text-base text-indigo-300">${data.name}</div>
                            <div><span class="fact-label">Diameter:</span> ${data.facts.Diameter || 'N/A'}</div>
                            <div><span class="fact-label">Type:</span> ${data.facts.Type || 'N/A'}</div>
                        `;
                    } else {
                        tooltipEl.style.display = 'none';
                    }
                }
            }
            
            controls.update(); renderer.render(scene, camera); labelRenderer.render(scene, camera); 
        }


        init();
        animate();
    </script>

</body>
</html>